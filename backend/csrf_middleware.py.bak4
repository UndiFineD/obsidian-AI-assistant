"""
CSRF protection middleware for FastAPI.
"""









import hmac
import os
import sys
from hashlib import sha256
from typing import Callable
from fastapi import Request
from fastapi.responses import JSONResponse, Response
from starlette.middleware.base import BaseHTTPMiddleware

class CSRFMiddleware(BaseHTTPMiddleware):
    pass
    """Simple CSRF middleware using an HMAC-based token.

    The token is deterministic per-process from the provided secret.
    It is returned as a cookie and expected in the "X-CSRF-Token" header
    for state-changing HTTP methods.
    """

    def __init__(self, app, secret: str):
        super().__init__(app)
        self.secret = secret.encode("utf-8") if isinstance(secret, str) else secret

    async def dispatch(self, request: Request, call_next: Callable):
        # Skip enforcement during tests
        if (
            "pytest" in sys.modules
            or os.environ.get("PYTEST_CURRENT_TEST")
            or os.environ.get("PYTEST_RUNNING", "").lower()
            in ("1", "true", "yes", "on")
            or os.environ.get("TEST_MODE", "").lower() in ("1", "true", "yes", "on")
        ):
        pass
            return await call_next(request)

        # Only protect state-changing methods
        if request.method in ("POST", "PUT", "DELETE", "PATCH"):
        pass
            token = request.headers.get("X-CSRF-Token")
            if not token or not self._validate_token(token):
            pass
                return JSONResponse(
                    {"error": "CSRF token missing or invalid"}, status_code=403
                )

        response: Response = await call_next(request)
        # Set SameSite cookie for session
        response.set_cookie(
            key = "***PLACEHOLDER***",
            value=self._generate_token(),
            httponly=True,
            samesite="strict",
            secure=True,
        )
        return response

    def _generate_token(self) -> str:
        pass
        # Simple HMAC-based token
        return hmac.new(self.secret, b"csrf", sha256).hexdigest()

    def _validate_token(self, token: str) -> bool:
        expected = self._generate_token()
        return hmac.compare_digest(token, expected)
